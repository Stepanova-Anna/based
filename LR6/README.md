# Лабораторное занятие №6
## Инвариантная часть
> В предметной области, предложенной преподавателем, реализовать реляционную  модель данных в MySQL Workbench. Спроектированная таблица должна отображать связи между сущностями, потенциальные ключи, условия проверки атрибутов.
>В данном задании необходимо обратиться к следующим документам:
> - Описание предметной области находится в приложении.
> - Задания

### Задания
1. Определите потенциальные ключи для каждого из отношений. Если для 
каких-то отношений таких ключей окажется несколько, выберите один из них 
на роль первичного (PK), а остальные пометьте альтернативными (AK).  

2. Определите, какие из атрибутов отношений являются обязательными, т.е. не 
допускают наличие неизвестных значений. Пометьте такие атрибуты как NOT 
NULL.  
3. Определите условия проверки значений для атрибутов (где возможно и, на 
ваш взгляд, имеет смысл). Условия требуется записать в виде логического 
выражения (предиката), в левой части которого указано имя атрибута, а в 
правой – значения, с которыми требуется произвести сравнение. Допускается 
использование реляционных (>, <, >=, <=, =, !=) и логических (AND, OR) 
операторов, а также оператора LIKE в том синтаксисе, с которым вы 
познакомились при выполнении лабораторной работы второй недели.  

4. Определите связи между отношениями.  

5. Установите связь между отношениями, добавив атрибуты первичного ключа 
главного отношения (того, к которому относится слово ОДИН) в состав 
дочернего (того, к которому относится слово МНОГО) и отметив их как 
внешний ключ (FK).  

6. Проверьте добавленные при установке связей атрибуты на обязательность, 
пометьте их как NOT NULL, если это требуется. Проверьте, не появились ли 
новые потенциальные ключи в результате добавления новых атрибутов.

7. Ответьте на вопрос (письменно): 
Допустим, что каждый сотрудник может обработать только один заказ (после 
чего его увольняют ). В этом случае, связь между отношениями ЗАКАЗ и 
СОТРУДНИК трансформируется в один-к-одному. Что нужно будет сделать 
дополнительно для поддержки этой связи? Что может помешать указать 
одного и того же сотрудника в отношении ЗАКАЗ, ответственным за 
обработку нескольких разных заказов? 

### Результат

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/игра.png)

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/заказ.png)

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/клиент.png)

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/сотрудник.png)

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/з3.png)

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/св1.png)

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/св2.png)

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/св3.png)

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/связи.png)

*6. Все внешние ключи, добавленные для установки связей, должны быть NOT NULL, так как они представляют обязательные связи между сущностями. Добавление атрибутов для связей не привело к появлению новых потенциальных ключей*

*7. Для поддержки связи 1:1 нужно:*
- *Добавить UNIQUE-ограничение на таб_номер в ЗАКАЗ (или на таб_номер в СОТРУДНИК)*
- *Реализовать проверки при вставке*

*Чтобы запретить повторное использование сотрудника, достаточно:*
- *UNIQUE-ограничения*
- *Или проверок в триггерах/приложении*

*Таким образом, связь будет строго один-к-одному, и сотрудник не сможет обрабатывать несколько заказов*

---

## Вариативная часть
> Вариант 1. Проанализировать информацию по избыточности баз данных и привести примеры неверного логического проектирования. Предложить алгоритм решения (по устранению) недостатков логической структуры. 

### Результат

**Избыточность — это дублирование данных, которое может приводить к:**

- Аномалиям обновления (необходимость синхронизации данных в нескольких местах)

- Увеличению размера БД

- Сложностям поддержки целостности

Избыточность данных:

- В таблице заказов может дублироваться информация о клиентах (имя, адрес)

- Цена игры может храниться как в таблице игр, так и в истории заказов

- Контактные данные сотрудников могут повторяться в разных заказах

Нарушение нормальных форм:

- В таблице игр могут храниться несколько жанров в одной записи 

- Информация о производителе может дублироваться для разных игр 

- Цена игры может зависеть не только от ID игры 

Отсутствие целостности:

- Нет внешних ключей для связи заказов с клиентами и сотрудниками

- Отсутствие проверок на минимальное/максимальное количество игроков

- Нет валидации email и телефонных номеров


**Алгоритм устранения недостатков**
**Шаг 1: Проверить нормальные формы**
1: Все атрибуты атомарны (нет списков в одной ячейке).

2: Нет зависимостей от части составного ключа.

3: Нет транзитивных зависимостей (все неключевые атрибуты зависят только от PK).

**Шаг 2: Устранить избыточность**
- Удалить дублирующиеся данные (например, client_name из ЗАКАЗ).

- Заменить вычисляемые поля на VIEW или триггеры (например, total_price).

**Шаг 3: Оптимизировать связи**
- Если связь 1:1 → проверить, не нужно ли сделать 1:N.

- Если связь M:N → убедиться, что есть промежуточная таблица.

**Шаг 4: Добавить ограничения целостности**
- PRIMARY KEY для всех сущностей.

- FOREIGN KEY для всех связей.

- CHECK для валидации данных (например, min_players >= 1).

**Шаг 5: Протестировать на реальных данных**
Вставить тестовые данные и проверить:

- Нет ли дублирования.

- Сохраняется ли целостность при обновлениях.
