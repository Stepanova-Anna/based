# Лабораторное занятие №6
## Инвариантная часть
> В предметной области, предложенной преподавателем, реализовать реляционную  модель данных в MySQL Workbench. Спроектированная таблица должна отображать связи между сущностями, потенциальные ключи, условия проверки атрибутов.
>В данном задании необходимо обратиться к следующим документам:
> - Описание предметной области находится в приложении.
> - Задания

### Задания
1. Определите потенциальные ключи для каждого из отношений. Если для 
каких-то отношений таких ключей окажется несколько, выберите один из них 
на роль первичного (PK), а остальные пометьте альтернативными (AK).  

2. Определите, какие из атрибутов отношений являются обязательными, т.е. не 
допускают наличие неизвестных значений. Пометьте такие атрибуты как NOT 
NULL.  
3. Определите условия проверки значений для атрибутов (где возможно и, на 
ваш взгляд, имеет смысл). Условия требуется записать в виде логического 
выражения (предиката), в левой части которого указано имя атрибута, а в 
правой – значения, с которыми требуется произвести сравнение. Допускается 
использование реляционных (>, <, >=, <=, =, !=) и логических (AND, OR) 
операторов, а также оператора LIKE в том синтаксисе, с которым вы 
познакомились при выполнении лабораторной работы второй недели.  

4. Определите связи между отношениями.  

5. Установите связь между отношениями, добавив атрибуты первичного ключа 
главного отношения (того, к которому относится слово ОДИН) в состав 
дочернего (того, к которому относится слово МНОГО) и отметив их как 
внешний ключ (FK).  

6. Проверьте добавленные при установке связей атрибуты на обязательность, 
пометьте их как NOT NULL, если это требуется. Проверьте, не появились ли 
новые потенциальные ключи в результате добавления новых атрибутов.

7. Ответьте на вопрос (письменно): 
Допустим, что каждый сотрудник может обработать только один заказ (после 
чего его увольняют ). В этом случае, связь между отношениями ЗАКАЗ и 
СОТРУДНИК трансформируется в один-к-одному. Что нужно будет сделать 
дополнительно для поддержки этой связи? Что может помешать указать 
одного и того же сотрудника в отношении ЗАКАЗ, ответственным за 
обработку нескольких разных заказов? 

### Результат

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/игра.png)

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/заказ.png)

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/клиент.png)

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/сотрудник.png)

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/з3.png)

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/св1.png)

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/св2.png)

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/св3.png)

![ЛР6.Задание 1](https://github.com/Stepanova-Anna/based/blob/main/LR6/связи.png)

*6. Все внешние ключи, добавленные для установки связей, должны быть NOT NULL, так как они представляют обязательные связи между сущностями. Добавление атрибутов для связей не привело к появлению новых потенциальных ключей.*

*7. Для поддержки связи 1:1 нужно:*
- *Добавить UNIQUE-ограничение на таб_номер в ЗАКАЗ (или на таб_номер в СОТРУДНИК).*
- *Реализовать проверки при вставке*

*Чтобы запретить повторное использование сотрудника, достаточно:*
- *UNIQUE-ограничения*
- *Или проверок в триггерах/приложении*

*Таким образом, связь будет строго один-к-одному, и сотрудник не сможет обрабатывать несколько заказов*
